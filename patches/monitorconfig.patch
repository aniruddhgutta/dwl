From b214bb056473c26e38c34d3fc4ccc0c4db99a34a Mon Sep 17 00:00:00 2001
From: aniruddhgutta <aniruddhgutta@disroot.org>
Date: Sat, 27 Sep 2025 05:37:57 +0530
Subject: [PATCH] Extra monitor configuration options

---
 config.def.h |  6 +++---
 dwl.c        | 25 +++++++++++++++++++------
 2 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/config.def.h b/config.def.h
index 09a8a72..d550500 100644
--- a/config.def.h
+++ b/config.def.h
@@ -45,9 +45,9 @@ static const Layout layouts[] = {
  *
  * AT LEAST ONE monitor rule must exist. Define at least a NULL default rule here. */
 static const MonitorRule monrules[] = {
-   /* name            mfact  nmaster scale layout       rotate/reflect                x    y */
-   { NULL,            0.55f, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
-   { "eDP-1_EXAMPLE", 0.5f,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,   -1,  -1 },
+    /* name            mfact  nmaster scale layout       rotate/reflect               x    y  resx resy rate mode adaptive*/
+    { NULL,            0.55f, 1,      1,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL, -1,  -1,  0,  0,  0.0f,  0,  1},
+	{ "eDP-1_EXAMPLE", 0.5f,  1,      2,    &layouts[0], WL_OUTPUT_TRANSFORM_NORMAL,  0,   0,  0,  0,  120.000f,  -1,  1},
 };
 
 /* keyboard */
diff --git a/dwl.c b/dwl.c
index 12f441e..6d75e60 100644
--- a/dwl.c
+++ b/dwl.c
@@ -215,6 +215,11 @@ typedef struct {
 	const Layout *lt;
 	enum wl_output_transform rr;
 	int x, y;
+	int resx;
+	int resy;
+	float rate;
+	int mode;
+	int adaptive;
 } MonitorRule;
 
 typedef struct {
@@ -1041,6 +1046,7 @@ createmon(struct wl_listener *listener, void *data)
 	/* This event is raised by the backend when a new output (aka a display or
 	 * monitor) becomes available. */
 	struct wlr_output *wlr_output = data;
+	struct wlr_output_mode *mode = wl_container_of(wlr_output->modes.next, mode, link);
 	const MonitorRule *r;
 	size_t i;
 	struct wlr_output_state state;
@@ -1069,16 +1075,23 @@ createmon(struct wl_listener *listener, void *data)
 			strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, LENGTH(m->ltsymbol));
 			wlr_output_state_set_scale(&state, r->scale);
 			wlr_output_state_set_transform(&state, r->rr);
+
+			wlr_output_state_set_adaptive_sync_enabled(&state, r->adaptive);
+
+			if(r->mode == -1)
+				wlr_output_state_set_custom_mode(&state, r->resx, r->resy,
+				(int) (r->rate > 0 ? r->rate * 1000 : 0));
+			else if (!wl_list_empty(&wlr_output->modes)) {
+				for (int j = 0; j < r->mode; j++) {
+					mode = wl_container_of(mode->link.next, mode, link);
+				}
+				wlr_output_state_set_mode(&state, mode);
+			}
+
 			break;
 		}
 	}
 
-	/* The mode is a tuple of (width, height, refresh rate), and each
-	 * monitor supports only a specific set of modes. We just pick the
-	 * monitor's preferred mode; a more sophisticated compositor would let
-	 * the user configure it. */
-	wlr_output_state_set_mode(&state, wlr_output_preferred_mode(wlr_output));
-
 	/* Set up event listeners */
 	LISTEN(&wlr_output->events.frame, &m->frame, rendermon);
 	LISTEN(&wlr_output->events.destroy, &m->destroy, cleanupmon);
-- 
2.51.0

